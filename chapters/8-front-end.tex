\chapter{Front-end}

Como falado no capítulo do arquitetura a página é gerada server-side, então
o que é retornado para cada rota é um HTML já pronto. Acredito que, para
meu caso é mais performático fazer assim, do que usar páginas com Javascript
que fazem requisição para uma API REST.

De todo modo, no final da execução de uma rota, um dicionário Python é gerado,
algo que poderia ser facilmento convertido para um JSON usando a função dumps()
da biblioteca 'json' do próprio Python. No caso desta aplicação este dicionário
é enviado para o template usando a função render\_template() do Jinja2 que recebe o nome da 
página HTML com o template e um número qualquer de kwargs, argumentos nomeados,
que podem ter qualquer tipo serializável includive dicionário.

Uma página template é um arquivo HTML com placeholders que serão substituídos
pelos kwargs de mesmo nome. O Jinja2 tem estruturas de repetição para que um
código HTML possa ser repetido usando valores de uma lista. E, no caso, de dicionários
é fácil acessar os valores. Neste projeto para exibir a lista de frequência, 
o seguinte código é usado.

\lstinputlisting[label=cod:jinja-comm,title={Título},caption={Modelo físico},language=SQL]{code/jinja-comm.html}

Note que é possível fazer operações e formatações simples no Jinja2. Já que a frequência é
armazenada no banco como um inteiro de ponto fixo, aqui eu divido o valor por mil
e formato com três casas decimais para que caso uma frequência termine com zeros
a direita sempre tenhamos três digitos decimais que é o padrão na para frequências
de comunicação.

No código do projeto na pasta 'templates' é possível ver todos os templates usados.